// Generated by dojo-bindgen on Sat, 2 Nov 2024 13:45:39 +0000. Do not modify this file manually.
import { Account } from "starknet";
import {
    Clause,
    Client,
    ModelClause,
    createClient,
    valueToToriiValueAndOperator,
} from "@dojoengine/torii-client";
import {
    LOCAL_KATANA,
    LOCAL_RELAY,
    LOCAL_TORII,
    createManifestFromJson,
} from "@dojoengine/core";

// Type definition for `core::byte_array::ByteArray` struct
export interface ByteArray {
    data: string[];
    pending_word: string;
    pending_word_len: number;
}

// Type definition for `dojo::model::layout::FieldLayout` struct
export interface FieldLayout {
    selector: string;
    layout: Layout;
}

// Type definition for `tournament::ls15_components::loot_survivor::AdventurerMetadata` struct
export interface AdventurerMetadata {
    birth_date: bigint;
    death_date: bigint;
    level_seed: bigint;
    item_specials_seed: number;
    rank_at_death: number;
    delay_stat_reveal: boolean;
    golden_token_id: number;
}

// Type definition for `tournament::ls15_components::loot_survivor::AdventurerMetaModel` struct
export interface AdventurerMetaModel {
    adventurer_id: string;
    adventurer_meta: AdventurerMetadata;
}

// Type definition for `core::option::Option::<core::integer::u32>` enum
type Option<A> = { type: 'Some'; data: A; } | { type: 'None'; }
// Type definition for `dojo::model::layout::Layout` enum
type Layout = { type: 'Fixed'; data: number[]; } | { type: 'Struct'; data: FieldLayout[]; } | { type: 'Tuple'; data: Layout[]; } | { type: 'Array'; data: Layout[]; } | { type: 'ByteArray'; } | { type: 'Enum'; data: FieldLayout[]; }

// Type definition for `tournament::ls15_components::loot_survivor::BagModel` struct
export interface BagModel {
    adventurer_id: string;
    bag: Bag;
}

// Type definition for `tournament::ls15_components::loot_survivor::Bag` struct
export interface Bag {
    item_1: Item;
    item_2: Item;
    item_3: Item;
    item_4: Item;
    item_5: Item;
    item_6: Item;
    item_7: Item;
    item_8: Item;
    item_9: Item;
    item_10: Item;
    item_11: Item;
    item_12: Item;
    item_13: Item;
    item_14: Item;
    item_15: Item;
    mutated: boolean;
}

// Type definition for `tournament::ls15_components::loot_survivor::Item` struct
export interface Item {
    id: number;
    xp: number;
}


// Type definition for `tournament::ls15_components::tournament::TournamentEntryModel` struct
export interface TournamentEntryModel {
    tournament_id: bigint;
    game_id: bigint;
    address: string;
    status: EntryStatus;
}

// Type definition for `tournament::ls15_components::constants::EntryStatus` enum
type EntryStatus = { type: 'Started'; } | { type: 'Submitted'; }

// Type definition for `tournament::ls15_components::tournament::TournamentEntriesModel` struct
export interface TournamentEntriesModel {
    tournament_id: bigint;
    entry_count: bigint;
    premiums_formatted: boolean;
    distribute_called: boolean;
}


// Type definition for `tournament::ls15_components::tournament::TournamentScoresModel` struct
export interface TournamentScoresModel {
    tournament_id: bigint;
    top_score_ids: bigint[];
}


// Type definition for `tournament::ls15_components::loot_survivor::Contracts` struct
export interface Contracts {
    contract: string;
    eth: string;
    lords: string;
    oracle: string;
}


// Type definition for `tournament::ls15_components::tournament::TournamentTotalsModel` struct
export interface TournamentTotalsModel {
    contract: string;
    total_tournaments: bigint;
    total_prizes: bigint;
}


// Type definition for `tournament::ls15_components::tournament::TournamentPrizeKeysModel` struct
export interface TournamentPrizeKeysModel {
    tournament_id: bigint;
    prize_keys: bigint[];
}


// Type definition for `tournament::ls15_components::tournament::TournamentModel` struct
export interface TournamentModel {
    tournament_id: bigint;
    name: string;
    description: string;
    creator: string;
    start_time: bigint;
    end_time: bigint;
    submission_period: bigint;
    winners_count: number;
    gated_type: Option<GatedType>;
    entry_premium: Option<Premium>;
}

// Type definition for `tournament::ls15_components::interfaces::Premium` struct
export interface Premium {
    token: string;
    token_amount: bigint;
    token_distribution: number[];
    creator_fee: number;
}

// Type definition for `tournament::ls15_components::interfaces::EntryCriteria` struct
export interface EntryCriteria {
    token_id: bigint;
    entry_count: bigint;
}

// Type definition for `tournament::ls15_components::interfaces::GatedToken` struct
export interface GatedToken {
    token: string;
    entry_type: GatedEntryType;
}

// Type definition for `tournament::ls15_components::constants::GatedType` enum
type GatedType = { type: 'token'; data: GatedToken; } | { type: 'tournament'; data: bigint[]; }
// Type definition for `tournament::ls15_components::constants::GatedEntryType` enum
type GatedEntryType = { type: 'criteria'; data: EntryCriteria[]; } | { type: 'uniform'; data: bigint; }

// Type definition for `tournament::ls15_components::loot_survivor::GameCountModel` struct
export interface GameCountModel {
    contract_address: string;
    game_count: bigint;
}


// Type definition for `tournament::ls15_components::tournament::TournamentStartIdsModel` struct
export interface TournamentStartIdsModel {
    tournament_id: bigint;
    address: string;
    game_ids: bigint[];
}


// Type definition for `tournament::ls15_components::tournament::TournamentContracts` struct
export interface TournamentContracts {
    contract: string;
    eth: string;
    lords: string;
    loot_survivor: string;
    oracle: string;
}


// Type definition for `tournament::ls15_components::loot_survivor::Equipment` struct
export interface Equipment {
    weapon: Item;
    chest: Item;
    head: Item;
    waist: Item;
    foot: Item;
    hand: Item;
    neck: Item;
    ring: Item;
}

// Type definition for `tournament::ls15_components::loot_survivor::Adventurer` struct
export interface Adventurer {
    health: number;
    xp: number;
    gold: number;
    beast_health: number;
    stat_upgrades_available: number;
    stats: Stats;
    equipment: Equipment;
    battle_action_count: number;
    mutated: boolean;
    awaiting_item_specials: boolean;
}

// Type definition for `tournament::ls15_components::loot_survivor::AdventurerModel` struct
export interface AdventurerModel {
    adventurer_id: string;
    adventurer: Adventurer;
}

// Type definition for `tournament::ls15_components::loot_survivor::Stats` struct
export interface Stats {
    strength: number;
    dexterity: number;
    vitality: number;
    intelligence: number;
    wisdom: number;
    charisma: number;
    luck: number;
}


// Type definition for `tournament::ls15_components::interfaces::ERC1155Data` struct
export interface ERC1155Data {
    token_id: bigint;
    token_amount: bigint;
}

// Type definition for `tournament::ls15_components::interfaces::ERC721Data` struct
export interface ERC721Data {
    token_id: bigint;
}

// Type definition for `tournament::ls15_components::interfaces::ERC20Data` struct
export interface ERC20Data {
    token_amount: bigint;
}

// Type definition for `tournament::ls15_components::tournament::PrizesModel` struct
export interface PrizesModel {
    prize_key: bigint;
    token: string;
    token_data_type: TokenDataType;
    payout_position: number;
    claimed: boolean;
}

// Type definition for `tournament::ls15_components::constants::TokenDataType` enum
type TokenDataType = { type: 'erc20'; data: ERC20Data; } | { type: 'erc721'; data: ERC721Data; } | { type: 'erc1155'; data: ERC1155Data; }

// Type definition for `tournament::ls15_components::tournament::TournamentEntriesAddressModel` struct
export interface TournamentEntriesAddressModel {
    tournament_id: bigint;
    address: string;
    entry_count: bigint;
}


// Type definition for `tournament::ls15_components::tournament::TournamentEntryAddressesModel` struct
export interface TournamentEntryAddressesModel {
    tournament_id: bigint;
    addresses: string[];
}


// Type definition for `tournament::ls15_components::tournament::TokenModel` struct
export interface TokenModel {
    token: string;
    name: string;
    symbol: string;
    token_data_type: TokenDataType;
    is_registered: boolean;
}


class BaseCalls {
    contractAddress: string;
    account?: Account;

    constructor(contractAddress: string, account?: Account) {
        this.account = account;
        this.contractAddress = contractAddress;
    }

    async execute(entrypoint: string, calldata: any[] = []): Promise<void> {
        if (!this.account) {
            throw new Error("No account set to interact with dojo_starter");
        }

        await this.account.execute(
            {
                contractAddress: this.contractAddress,
                entrypoint,
                calldata,
            },
            undefined,
            {
                maxFee: 0,
            }
        );
    }
}

class LsTournamentCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async initializer(eth_address: string, lords_address: string, loot_survivor_address: string, oracle_address: string): Promise<void> {
        try {
            await this.execute("initializer", [eth_address,
                lords_address,
                loot_survivor_address,
                oracle_address])
        } catch (error) {
            console.error("Error executing initializer:", error);
            throw error;
        }
    }

    async totalTournaments(): Promise<void> {
        try {
            await this.execute("total_tournaments", [])
        } catch (error) {
            console.error("Error executing totalTournaments:", error);
            throw error;
        }
    }

    async tournament(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("tournament", [tournament_id])
        } catch (error) {
            console.error("Error executing tournament:", error);
            throw error;
        }
    }

    async tournamentEntries(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("tournament_entries", [tournament_id])
        } catch (error) {
            console.error("Error executing tournamentEntries:", error);
            throw error;
        }
    }

    async tournamentPrizeKeys(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("tournament_prize_keys", [tournament_id])
        } catch (error) {
            console.error("Error executing tournamentPrizeKeys:", error);
            throw error;
        }
    }

    async topScores(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("top_scores", [tournament_id])
        } catch (error) {
            console.error("Error executing topScores:", error);
            throw error;
        }
    }

    async isTournamentActive(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("is_tournament_active", [tournament_id])
        } catch (error) {
            console.error("Error executing isTournamentActive:", error);
            throw error;
        }
    }

    async isTokenRegistered(token: string): Promise<void> {
        try {
            await this.execute("is_token_registered", [token])
        } catch (error) {
            console.error("Error executing isTokenRegistered:", error);
            throw error;
        }
    }

    async createTournament(name: string, description: string, start_time: bigint, end_time: bigint, submission_period: bigint, winners_count: number, gated_type: Option<GatedType>, entry_premium: Option<GatedType>): Promise<void> {
        try {
            await this.execute("create_tournament", [name,
                props.description.data,
                    props.description.pending_word,
                    props.description.pending_word_len,
                start_time,
                end_time,
                submission_period,
                winners_count,
                gated_type,
                entry_premium])
        } catch (error) {
            console.error("Error executing createTournament:", error);
            throw error;
        }
    }

    async registerTokens(tokens: Token[]): Promise<void> {
        try {
            await this.execute("register_tokens", [tokens])
        } catch (error) {
            console.error("Error executing registerTokens:", error);
            throw error;
        }
    }

    async enterTournament(tournament_id: bigint, gated_submission_type: Option<GatedType>): Promise<void> {
        try {
            await this.execute("enter_tournament", [tournament_id,
                gated_submission_type])
        } catch (error) {
            console.error("Error executing enterTournament:", error);
            throw error;
        }
    }

    async startTournament(tournament_id: bigint, start_all: boolean, start_count: Option<GatedType>): Promise<void> {
        try {
            await this.execute("start_tournament", [tournament_id,
                start_all,
                start_count])
        } catch (error) {
            console.error("Error executing startTournament:", error);
            throw error;
        }
    }

    async submitScores(tournament_id: bigint, game_ids: string[]): Promise<void> {
        try {
            await this.execute("submit_scores", [tournament_id,
                game_ids])
        } catch (error) {
            console.error("Error executing submitScores:", error);
            throw error;
        }
    }

    async addPrize(tournament_id: bigint, token: string, token_data_type: TokenDataType, position: number): Promise<void> {
        try {
            await this.execute("add_prize", [tournament_id,
                token,
                token_data_type,
                position])
        } catch (error) {
            console.error("Error executing addPrize:", error);
            throw error;
        }
    }

    async distributePrizes(tournament_id: bigint, prize_keys: bigint[]): Promise<void> {
        try {
            await this.execute("distribute_prizes", [tournament_id,
                prize_keys])
        } catch (error) {
            console.error("Error executing distributePrizes:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }
}
class Erc20MockCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async totalSupply(): Promise<void> {
        try {
            await this.execute("total_supply", [])
        } catch (error) {
            console.error("Error executing totalSupply:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async allowance(owner: string, spender: string): Promise<void> {
        try {
            await this.execute("allowance", [owner,
                spender])
        } catch (error) {
            console.error("Error executing allowance:", error);
            throw error;
        }
    }

    async transfer(recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transfer", [recipient,
                amount])
        } catch (error) {
            console.error("Error executing transfer:", error);
            throw error;
        }
    }

    async transferFrom(sender: string, recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [sender,
                recipient,
                amount])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async approve(spender: string, amount: U256): Promise<void> {
        try {
            await this.execute("approve", [spender,
                amount])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async decimals(): Promise<void> {
        try {
            await this.execute("decimals", [])
        } catch (error) {
            console.error("Error executing decimals:", error);
            throw error;
        }
    }

    async totalSupply(): Promise<void> {
        try {
            await this.execute("totalSupply", [])
        } catch (error) {
            console.error("Error executing totalSupply:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async transferFrom(sender: string, recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [sender,
                recipient,
                amount])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async mint(recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("mint", [recipient,
                amount])
        } catch (error) {
            console.error("Error executing mint:", error);
            throw error;
        }
    }
}
class PragmaMockCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async getDataMedian(data_type: DataType): Promise<void> {
        try {
            await this.execute("get_data_median", [data_type])
        } catch (error) {
            console.error("Error executing getDataMedian:", error);
            throw error;
        }
    }
}
class Erc1155MockCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async mint(recipient: string, token_id: U256, value: U256): Promise<void> {
        try {
            await this.execute("mint", [recipient,
                token_id,
                value])
        } catch (error) {
            console.error("Error executing mint:", error);
            throw error;
        }
    }

    async balanceOf(account: string, token_id: U256): Promise<void> {
        try {
            await this.execute("balance_of", [account,
                token_id])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async balanceOfBatch(accounts: string[], token_ids: U256[]): Promise<void> {
        try {
            await this.execute("balance_of_batch", [accounts,
                token_ids])
        } catch (error) {
            console.error("Error executing balanceOfBatch:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, token_id: U256, value: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safe_transfer_from", [from,
                to,
                token_id,
                value,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async safeBatchTransferFrom(from: string, to: string, token_ids: U256[], values: U256[], data: string[]): Promise<void> {
        try {
            await this.execute("safe_batch_transfer_from", [from,
                to,
                token_ids,
                values,
                data])
        } catch (error) {
            console.error("Error executing safeBatchTransferFrom:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("is_approved_for_all", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("set_approval_for_all", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async supportsInterface(interface_id: string): Promise<void> {
        try {
            await this.execute("supports_interface", [interface_id])
        } catch (error) {
            console.error("Error executing supportsInterface:", error);
            throw error;
        }
    }

    async uri(token_id: U256): Promise<void> {
        try {
            await this.execute("uri", [token_id])
        } catch (error) {
            console.error("Error executing uri:", error);
            throw error;
        }
    }

    async balanceOf(account: string, tokenId: U256): Promise<void> {
        try {
            await this.execute("balanceOf", [account,
                tokenId])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async balanceOfBatch(accounts: string[], tokenIds: U256[]): Promise<void> {
        try {
            await this.execute("balanceOfBatch", [accounts,
                tokenIds])
        } catch (error) {
            console.error("Error executing balanceOfBatch:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, tokenId: U256, value: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safeTransferFrom", [from,
                to,
                tokenId,
                value,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async safeBatchTransferFrom(from: string, to: string, tokenIds: U256[], values: U256[], data: string[]): Promise<void> {
        try {
            await this.execute("safeBatchTransferFrom", [from,
                to,
                tokenIds,
                values,
                data])
        } catch (error) {
            console.error("Error executing safeBatchTransferFrom:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("isApprovedForAll", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("setApprovalForAll", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }
}
class TournamentMockCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async totalTournaments(): Promise<void> {
        try {
            await this.execute("total_tournaments", [])
        } catch (error) {
            console.error("Error executing totalTournaments:", error);
            throw error;
        }
    }

    async tournament(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("tournament", [tournament_id])
        } catch (error) {
            console.error("Error executing tournament:", error);
            throw error;
        }
    }

    async tournamentEntries(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("tournament_entries", [tournament_id])
        } catch (error) {
            console.error("Error executing tournamentEntries:", error);
            throw error;
        }
    }

    async tournamentPrizeKeys(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("tournament_prize_keys", [tournament_id])
        } catch (error) {
            console.error("Error executing tournamentPrizeKeys:", error);
            throw error;
        }
    }

    async topScores(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("top_scores", [tournament_id])
        } catch (error) {
            console.error("Error executing topScores:", error);
            throw error;
        }
    }

    async isTournamentActive(tournament_id: bigint): Promise<void> {
        try {
            await this.execute("is_tournament_active", [tournament_id])
        } catch (error) {
            console.error("Error executing isTournamentActive:", error);
            throw error;
        }
    }

    async isTokenRegistered(token: string): Promise<void> {
        try {
            await this.execute("is_token_registered", [token])
        } catch (error) {
            console.error("Error executing isTokenRegistered:", error);
            throw error;
        }
    }

    async createTournament(name: string, description: string, start_time: bigint, end_time: bigint, submission_period: bigint, winners_count: number, gated_type: Option<GatedType>, entry_premium: Option<GatedType>): Promise<void> {
        try {
            await this.execute("create_tournament", [name,
                props.description.data,
                    props.description.pending_word,
                    props.description.pending_word_len,
                start_time,
                end_time,
                submission_period,
                winners_count,
                gated_type,
                entry_premium])
        } catch (error) {
            console.error("Error executing createTournament:", error);
            throw error;
        }
    }

    async registerTokens(tokens: Token[]): Promise<void> {
        try {
            await this.execute("register_tokens", [tokens])
        } catch (error) {
            console.error("Error executing registerTokens:", error);
            throw error;
        }
    }

    async enterTournament(tournament_id: bigint, gated_submission_type: Option<GatedType>): Promise<void> {
        try {
            await this.execute("enter_tournament", [tournament_id,
                gated_submission_type])
        } catch (error) {
            console.error("Error executing enterTournament:", error);
            throw error;
        }
    }

    async startTournament(tournament_id: bigint, start_all: boolean, start_count: Option<GatedType>): Promise<void> {
        try {
            await this.execute("start_tournament", [tournament_id,
                start_all,
                start_count])
        } catch (error) {
            console.error("Error executing startTournament:", error);
            throw error;
        }
    }

    async submitScores(tournament_id: bigint, game_ids: string[]): Promise<void> {
        try {
            await this.execute("submit_scores", [tournament_id,
                game_ids])
        } catch (error) {
            console.error("Error executing submitScores:", error);
            throw error;
        }
    }

    async addPrize(tournament_id: bigint, token: string, token_data_type: TokenDataType, position: number): Promise<void> {
        try {
            await this.execute("add_prize", [tournament_id,
                token,
                token_data_type,
                position])
        } catch (error) {
            console.error("Error executing addPrize:", error);
            throw error;
        }
    }

    async distributePrizes(tournament_id: bigint, prize_keys: bigint[]): Promise<void> {
        try {
            await this.execute("distribute_prizes", [tournament_id,
                prize_keys])
        } catch (error) {
            console.error("Error executing distributePrizes:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async initializer(eth_address: string, lords_address: string, loot_survivor_address: string, oracle_address: string): Promise<void> {
        try {
            await this.execute("initializer", [eth_address,
                lords_address,
                loot_survivor_address,
                oracle_address])
        } catch (error) {
            console.error("Error executing initializer:", error);
            throw error;
        }
    }
}
class LootSurvivorMockCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async initializer(name: string, symbol: string, base_uri: string, eth_address: string, lords_address: string, pragma_address: string): Promise<void> {
        try {
            await this.execute("initializer", [props.name.data,
                    props.name.pending_word,
                    props.name.pending_word_len,
                props.symbol.data,
                    props.symbol.pending_word,
                    props.symbol.pending_word_len,
                props.base_uri.data,
                    props.base_uri.pending_word,
                    props.base_uri.pending_word_len,
                eth_address,
                lords_address,
                pragma_address])
        } catch (error) {
            console.error("Error executing initializer:", error);
            throw error;
        }
    }

    async getAdventurer(adventurer_id: string): Promise<void> {
        try {
            await this.execute("get_adventurer", [adventurer_id])
        } catch (error) {
            console.error("Error executing getAdventurer:", error);
            throw error;
        }
    }

    async getAdventurerMeta(adventurer_id: string): Promise<void> {
        try {
            await this.execute("get_adventurer_meta", [adventurer_id])
        } catch (error) {
            console.error("Error executing getAdventurerMeta:", error);
            throw error;
        }
    }

    async getBag(adventurer_id: string): Promise<void> {
        try {
            await this.execute("get_bag", [adventurer_id])
        } catch (error) {
            console.error("Error executing getBag:", error);
            throw error;
        }
    }

    async getCostToPlay(): Promise<void> {
        try {
            await this.execute("get_cost_to_play", [])
        } catch (error) {
            console.error("Error executing getCostToPlay:", error);
            throw error;
        }
    }

    async newGame(client_reward_address: string, weapon: number, name: string, golden_token_id: number, delay_reveal: boolean, custom_renderer: string, launch_tournament_winner_token_id: bigint, mint_to: string): Promise<void> {
        try {
            await this.execute("new_game", [client_reward_address,
                weapon,
                name,
                golden_token_id,
                delay_reveal,
                custom_renderer,
                launch_tournament_winner_token_id,
                mint_to])
        } catch (error) {
            console.error("Error executing newGame:", error);
            throw error;
        }
    }

    async setAdventurer(adventurer_id: string, adventurer: Adventurer): Promise<void> {
        try {
            await this.execute("set_adventurer", [adventurer_id,
                props.adventurer.health,
                    props.adventurer.xp,
                    props.adventurer.gold,
                    props.adventurer.beast_health,
                    props.adventurer.stat_upgrades_available,
                    props.adventurer.stats,
                    props.adventurer.equipment,
                    props.adventurer.battle_action_count,
                    props.adventurer.mutated,
                    props.adventurer.awaiting_item_specials])
        } catch (error) {
            console.error("Error executing setAdventurer:", error);
            throw error;
        }
    }

    async setAdventurerMeta(adventurer_id: string, adventurer_meta: AdventurerMetadata): Promise<void> {
        try {
            await this.execute("set_adventurer_meta", [adventurer_id,
                props.adventurer_meta.birth_date,
                    props.adventurer_meta.death_date,
                    props.adventurer_meta.level_seed,
                    props.adventurer_meta.item_specials_seed,
                    props.adventurer_meta.rank_at_death,
                    props.adventurer_meta.delay_stat_reveal,
                    props.adventurer_meta.golden_token_id])
        } catch (error) {
            console.error("Error executing setAdventurerMeta:", error);
            throw error;
        }
    }

    async setBag(adventurer_id: string, bag: Bag): Promise<void> {
        try {
            await this.execute("set_bag", [adventurer_id,
                props.bag.item_1,
                    props.bag.item_2,
                    props.bag.item_3,
                    props.bag.item_4,
                    props.bag.item_5,
                    props.bag.item_6,
                    props.bag.item_7,
                    props.bag.item_8,
                    props.bag.item_9,
                    props.bag.item_10,
                    props.bag.item_11,
                    props.bag.item_12,
                    props.bag.item_13,
                    props.bag.item_14,
                    props.bag.item_15,
                    props.bag.mutated])
        } catch (error) {
            console.error("Error executing setBag:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(token_id: U256): Promise<void> {
        try {
            await this.execute("owner_of", [token_id])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, token_id: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safe_transfer_from", [from,
                to,
                token_id,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [from,
                to,
                token_id])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async approve(to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("approve", [to,
                token_id])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("set_approval_for_all", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(token_id: U256): Promise<void> {
        try {
            await this.execute("get_approved", [token_id])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("is_approved_for_all", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async supportsInterface(interface_id: string): Promise<void> {
        try {
            await this.execute("supports_interface", [interface_id])
        } catch (error) {
            console.error("Error executing supportsInterface:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async tokenUri(token_id: U256): Promise<void> {
        try {
            await this.execute("token_uri", [token_id])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(tokenId: U256): Promise<void> {
        try {
            await this.execute("ownerOf", [tokenId])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, tokenId: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safeTransferFrom", [from,
                to,
                tokenId,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, tokenId: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [from,
                to,
                tokenId])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("setApprovalForAll", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(tokenId: U256): Promise<void> {
        try {
            await this.execute("getApproved", [tokenId])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("isApprovedForAll", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async tokenUri(tokenId: U256): Promise<void> {
        try {
            await this.execute("tokenURI", [tokenId])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }
}
class Erc721MockCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(token_id: U256): Promise<void> {
        try {
            await this.execute("owner_of", [token_id])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, token_id: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safe_transfer_from", [from,
                to,
                token_id,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [from,
                to,
                token_id])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async approve(to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("approve", [to,
                token_id])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("set_approval_for_all", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(token_id: U256): Promise<void> {
        try {
            await this.execute("get_approved", [token_id])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("is_approved_for_all", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async supportsInterface(interface_id: string): Promise<void> {
        try {
            await this.execute("supports_interface", [interface_id])
        } catch (error) {
            console.error("Error executing supportsInterface:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async tokenUri(token_id: U256): Promise<void> {
        try {
            await this.execute("token_uri", [token_id])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(tokenId: U256): Promise<void> {
        try {
            await this.execute("ownerOf", [tokenId])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, tokenId: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safeTransferFrom", [from,
                to,
                tokenId,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, tokenId: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [from,
                to,
                tokenId])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("setApprovalForAll", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(tokenId: U256): Promise<void> {
        try {
            await this.execute("getApproved", [tokenId])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("isApprovedForAll", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async tokenUri(tokenId: U256): Promise<void> {
        try {
            await this.execute("tokenURI", [tokenId])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async mint(recipient: string, token_id: U256): Promise<void> {
        try {
            await this.execute("mint", [recipient,
                token_id])
        } catch (error) {
            console.error("Error executing mint:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }
}

type Query = Partial<{
    AdventurerMetaModel: ModelClause<AdventurerMetaModel>;
    BagModel: ModelClause<BagModel>;
    TournamentEntryModel: ModelClause<TournamentEntryModel>;
    TournamentEntriesModel: ModelClause<TournamentEntriesModel>;
    TournamentScoresModel: ModelClause<TournamentScoresModel>;
    Contracts: ModelClause<Contracts>;
    TournamentTotalsModel: ModelClause<TournamentTotalsModel>;
    TournamentPrizeKeysModel: ModelClause<TournamentPrizeKeysModel>;
    TournamentModel: ModelClause<TournamentModel>;
    GameCountModel: ModelClause<GameCountModel>;
    TournamentStartIdsModel: ModelClause<TournamentStartIdsModel>;
    TournamentContracts: ModelClause<TournamentContracts>;
    AdventurerModel: ModelClause<AdventurerModel>;
    PrizesModel: ModelClause<PrizesModel>;
    TournamentEntriesAddressModel: ModelClause<TournamentEntriesAddressModel>;
    TournamentEntryAddressesModel: ModelClause<TournamentEntryAddressesModel>;
    TokenModel: ModelClause<TokenModel>;
}>;

type ResultMapping = {
    AdventurerMetaModel: AdventurerMetaModel;
    BagModel: BagModel;
    TournamentEntryModel: TournamentEntryModel;
    TournamentEntriesModel: TournamentEntriesModel;
    TournamentScoresModel: TournamentScoresModel;
    Contracts: Contracts;
    TournamentTotalsModel: TournamentTotalsModel;
    TournamentPrizeKeysModel: TournamentPrizeKeysModel;
    TournamentModel: TournamentModel;
    GameCountModel: GameCountModel;
    TournamentStartIdsModel: TournamentStartIdsModel;
    TournamentContracts: TournamentContracts;
    AdventurerModel: AdventurerModel;
    PrizesModel: PrizesModel;
    TournamentEntriesAddressModel: TournamentEntriesAddressModel;
    TournamentEntryAddressesModel: TournamentEntryAddressesModel;
    TokenModel: TokenModel;
};

type QueryResult<T extends Query> = {
    [K in keyof T]: K extends keyof ResultMapping ? ResultMapping[K] : never;
};

// Only supports a single model for now, since torii doesn't support multiple models
// And inside that single model, there's only support for a single query.
function convertQueryToToriiClause(query: Query): Clause | undefined {
    const [model, clause] = Object.entries(query)[0];

    if (Object.keys(clause).length === 0) {
        return undefined;
    }

    const clauses: Clause[] = Object.entries(clause).map(([key, value]) => {
        return {
            Member: {
                model,
                member: key,
                ...valueToToriiValueAndOperator(value),
            },
        } satisfies Clause;
    });

    return clauses[0];
}
type GeneralParams = {
    toriiUrl?: string;
    relayUrl?: string;
    account?: Account;
};

type InitialParams = GeneralParams &
    (
        | {
                rpcUrl?: string;
                worldAddress: string;
                lsTournamentAddress: string;
    erc20MockAddress: string;
    pragmaMockAddress: string;
    erc1155MockAddress: string;
    tournamentMockAddress: string;
    lootSurvivorMockAddress: string;
    erc721MockAddress: string;
            }
        | {
                manifest: any;
            }
    );

export class Tournament {
    rpcUrl: string;
    toriiUrl: string;
    toriiPromise: Promise<Client>;
    relayUrl: string;
    worldAddress: string;
    private _account?: Account;
    lsTournament: LsTournamentCalls;
    lsTournamentAddress: string;
    erc20Mock: Erc20MockCalls;
    erc20MockAddress: string;
    pragmaMock: PragmaMockCalls;
    pragmaMockAddress: string;
    erc1155Mock: Erc1155MockCalls;
    erc1155MockAddress: string;
    tournamentMock: TournamentMockCalls;
    tournamentMockAddress: string;
    lootSurvivorMock: LootSurvivorMockCalls;
    lootSurvivorMockAddress: string;
    erc721Mock: Erc721MockCalls;
    erc721MockAddress: string;

    constructor(params: InitialParams) {
        if ("manifest" in params) {
            const config = createManifestFromJson(params.manifest);
            this.rpcUrl = config.world.metadata.rpc_url;
            this.worldAddress = config.world.address;

            const lsTournamentAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::lsTournament::lsTournament"
            )?.address;

            if (!lsTournamentAddress) {
                throw new Error("No lsTournament contract found in the manifest");
            }

            this.lsTournamentAddress = lsTournamentAddress;
    const erc20MockAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::erc20Mock::erc20Mock"
            )?.address;

            if (!erc20MockAddress) {
                throw new Error("No erc20Mock contract found in the manifest");
            }

            this.erc20MockAddress = erc20MockAddress;
    const pragmaMockAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::pragmaMock::pragmaMock"
            )?.address;

            if (!pragmaMockAddress) {
                throw new Error("No pragmaMock contract found in the manifest");
            }

            this.pragmaMockAddress = pragmaMockAddress;
    const erc1155MockAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::erc1155Mock::erc1155Mock"
            )?.address;

            if (!erc1155MockAddress) {
                throw new Error("No erc1155Mock contract found in the manifest");
            }

            this.erc1155MockAddress = erc1155MockAddress;
    const tournamentMockAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::tournamentMock::tournamentMock"
            )?.address;

            if (!tournamentMockAddress) {
                throw new Error("No tournamentMock contract found in the manifest");
            }

            this.tournamentMockAddress = tournamentMockAddress;
    const lootSurvivorMockAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::lootSurvivorMock::lootSurvivorMock"
            )?.address;

            if (!lootSurvivorMockAddress) {
                throw new Error("No lootSurvivorMock contract found in the manifest");
            }

            this.lootSurvivorMockAddress = lootSurvivorMockAddress;
    const erc721MockAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::erc721Mock::erc721Mock"
            )?.address;

            if (!erc721MockAddress) {
                throw new Error("No erc721Mock contract found in the manifest");
            }

            this.erc721MockAddress = erc721MockAddress;
        } else {
            this.rpcUrl = params.rpcUrl || LOCAL_KATANA;
            this.worldAddress = params.worldAddress;
            this.lsTournamentAddress = params.lsTournamentAddress;
    this.erc20MockAddress = params.erc20MockAddress;
    this.pragmaMockAddress = params.pragmaMockAddress;
    this.erc1155MockAddress = params.erc1155MockAddress;
    this.tournamentMockAddress = params.tournamentMockAddress;
    this.lootSurvivorMockAddress = params.lootSurvivorMockAddress;
    this.erc721MockAddress = params.erc721MockAddress;
        }
        this.toriiUrl = params.toriiUrl || LOCAL_TORII;
        this.relayUrl = params.relayUrl || LOCAL_RELAY;
        this._account = params.account;
        this.lsTournament = new LsTournamentCalls(this.lsTournamentAddress, this._account);
    this.erc20Mock = new Erc20MockCalls(this.erc20MockAddress, this._account);
    this.pragmaMock = new PragmaMockCalls(this.pragmaMockAddress, this._account);
    this.erc1155Mock = new Erc1155MockCalls(this.erc1155MockAddress, this._account);
    this.tournamentMock = new TournamentMockCalls(this.tournamentMockAddress, this._account);
    this.lootSurvivorMock = new LootSurvivorMockCalls(this.lootSurvivorMockAddress, this._account);
    this.erc721Mock = new Erc721MockCalls(this.erc721MockAddress, this._account);

        this.toriiPromise = createClient([], {
            rpcUrl: this.rpcUrl,
            toriiUrl: this.toriiUrl,
            worldAddress: this.worldAddress,
            relayUrl: this.relayUrl,
        });
    }

    get account(): Account | undefined {
        return this._account;
    }

    set account(account: Account) {
        this._account = account;
        this.lsTournament = new LsTournamentCalls(this.lsTournamentAddress, this._account);
    this.erc20Mock = new Erc20MockCalls(this.erc20MockAddress, this._account);
    this.pragmaMock = new PragmaMockCalls(this.pragmaMockAddress, this._account);
    this.erc1155Mock = new Erc1155MockCalls(this.erc1155MockAddress, this._account);
    this.tournamentMock = new TournamentMockCalls(this.tournamentMockAddress, this._account);
    this.lootSurvivorMock = new LootSurvivorMockCalls(this.lootSurvivorMockAddress, this._account);
    this.erc721Mock = new Erc721MockCalls(this.erc721MockAddress, this._account);
    }

    async query<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        return {
            torii,
            findEntities: async () => this.findEntities(query, limit, offset),
        };
    }

    async findEntities<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        const clause = convertQueryToToriiClause(query);

        const toriiResult = await torii.getEntities({
            limit,
            offset,
            clause,
        });

        return toriiResult as Record<string, QueryResult<T>>;
    }

    async findEntity<T extends Query>(query: T) {
        const result = await this.findEntities(query, 1);

        if (Object.values(result).length === 0) {
            return undefined;
        }

        return Object.values(result)[0] as QueryResult<T>;
    }
}